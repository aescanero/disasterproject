---
- name: Add kernel modules
  modprobe:
    name: "{{ item }}"
    state: present
  with_items:
    - overlay
    - br_netfilter

- sysctl:
    name: net.ipv4.ip_forward
    value: "1"
    sysctl_set: yes
    state: present

- sysctl:
    name: net.bridge.bridge-nf-call-iptables
    value: "1"
    sysctl_set: yes
    state: present

- name: Update repositories cache and install dirmngr and curl packages
  apt:
    name: "{{ packages }}"
    update_cache: yes
  vars:
    packages:
    - ebtables
    - ethtool 
    - curl
    - socat
    - libseccomp2
    - conntrack
    - ipvsadm
  when: ansible_os_family == "Debian"

- name: Update repositories cache and install kubernetes dependences
  yum:
    name: "{{ packages }}"
    state: latest
  vars:
    packages:
    - ebtables
    - ethtool 
    - curl
    - socat
    - libseccomp
    - conntrack-tools
    - ipvsadm
  when: ansible_os_family == "Redhat"

- name: Creates directory cni
  file:
    path: /opt/cni/bin
    state: directory

- name: install k3s
  get_url:
    url: https://github.com/rancher/k3s/releases/latest/download/k3s
    dest: /usr/bin/k3s
    mode: '0755'
    username: root
    group: root

- name: obtiene el nombre del master
  command: echo "{{ inventory_hostname }}"
  register: master_name
  run_once: true
  when: master_name is not defined

- name: install /etc/systemd/system/k3smaster.service on master
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  copy:
    dest: /etc/systemd/system/k3smaster.service
    content: |
      [Unit]
      Description=k3s
      
      [Service]
      ExecStart=/usr/bin/k3s server --no-deploy servicelb --bind-address {{ vm_ip }}
      Restart=always
      StartLimitInterval=0
      RestartSec=10
      
      [Install]
      WantedBy=multi-user.target

- name: enable and start k3smaster service on master
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  systemd:
    name: k3smaster
    daemon_reload: yes
    enabled: yes
    masked: no
    state: started

- name: Wait to raise k3s master
  pause:
    seconds: 20

- name: Load k3s token into variable
  when: master_name is defined and master_name.stdout == inventory_hostname
  slurp:
    src: "/var/lib/rancher/k3s/server/node-token"
  register: token
  run_once: true

- name: Creates directory
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  file:
    path: ~/.kube
    state: directory

- name: Configure config for k3s kubectl
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  shell: "{{ item }}"
  with_items:
    - cp -i /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
    - k3s kubectl apply -f "https://raw.githubusercontent.com/danderson/metallb/master/manifests/metallb.yaml"

- name: Define a default external pool for Kubernetes
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  copy:
    dest: "{{ ansible_env.HOME }}/pool.yml"
    content: |
      apiVersion: v1
      kind: ConfigMap
      metadata:
        namespace: metallb-system
        name: config
      data:
        config: |
          address-pools:
          - name: my-ip-space
            protocol: layer2
            addresses:
            - 192.168.8.240/28

- name: Define a service for Dashboard
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  copy:
    dest: "{{ ansible_env.HOME }}/service.yml"
    content: |
      apiVersion: v1
      kind: Service
      metadata:
        name: k8dashlb
        namespace: kube-system
      spec:
        ports:
        - name: http
          port: 80
          protocol: TCP
          targetPort: 4654
        selector:
          k8s-app: k8dash
        type: LoadBalancer

- name: Configure network pool and Dashboard
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  shell: "{{ item }}"
  with_items:
    - k3s kubectl apply -f {{ ansible_env.HOME }}/pool.yml
    - k3s kubectl apply -f "https://raw.githubusercontent.com/herbrandson/k8dash/master/kubernetes-k8dash.yaml"
    - k3s kubectl apply -f {{ ansible_env.HOME }}/service.yml

- name: Create k8dash sa
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  shell: "{{ item }}"
  with_items:
    - k3s kubectl create serviceaccount k8dash-sa
    - k3s kubectl create clusterrolebinding k8dash-sa --clusterrole=cluster-admin --serviceaccount=default:k8dash-sa

- name: install /etc/systemd/system/k3s.service on nodes
  when: master_name is defined and master_name.stdout != inventory_hostname
  copy:
    dest: /etc/systemd/system/k3s.service
    content: |
      [Unit]
      Description=k3s
      
      [Service]
      ExecStart=/usr/bin/k3s agent --server https://{{ master_name.stdout }}:6443 --token {{ token.content |  b64decode }}
      Restart=always
      StartLimitInterval=0
      RestartSec=10
      
      [Install]
      WantedBy=multi-user.target

- name: enable and start k3s service on nodes
  when: master_name is defined and master_name.stdout != inventory_hostname
  systemd:
    name: k3s
    daemon_reload: yes
    enabled: yes
    masked: no
    state: started

- name: Wait to raise k3s nodes
  pause:
    seconds: 20

- name: Install addons
  when: k3s_addons is defined and master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  include: "{{ loop_item }}.yml"
  with_items: "{{ k3s_addons }}"
  loop_control:
    loop_var: loop_item

- name: Obtain dashboard IP
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  shell: k3s kubectl get service -n kube-system k8dashlb -o jsonpath='{.status.loadBalancer.ingress[].ip}'
  register: k8dash_ip
  retries: 3
  delay: 5
  until: k8dash_ip.stdout != ""

- name: Obtain dashboard Token
  when: master_name is defined and master_name.stdout == inventory_hostname
  run_once: true
  shell: k3s kubectl get secret `k3s kubectl get secret|grep ^k8dash|awk '{print $1}'` -o jsonpath="{.data.token}"|base64 -d
  register: k8dash_token

- name: display post install message
  debug:
    msg: |
      Things left to do:
        - Access to https://{{k8dash_ip.stdout}}
        - Use the next token to access dashboard: {{k8dash_token.stdout}}
...
